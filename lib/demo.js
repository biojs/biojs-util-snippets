var request = require("request");
var q = require('bluebird');
var _ = require("underscore");
var utils = require("./utils");
var loadJS = require("./loadJS");
var loadHTML = require("./loadHTML");

module.exports = function(opts) {
  var currentSnip = opts.snippetName;
  var pkg = opts.pkg;
  var snip = pkg.sniper || pkg.latest.sniper;
  var services = {
    browserifyCDN: "https://wzrd.in/bundle/",
    rawgit: "https://cdn.rawgit.com/",
    parcelifyCDN: "http://parce.li/bundle/"
  };
  _.extend(services, opts.services);

  snip.name = pkg.name;
  var details = {
    pkg: pkg,
    currentSnip: currentSnip,
  };

  // dirty hack to avoid browserify for apinatomy
  var noBrowserify = snip.noBrowserify;

  return new q.Promise(function(superResolve, superReject) {

    if (pkg.github === undefined || snip.srcs === undefined) {
      return superReject({
        msg: "No file on github found.",
        code: "noGithub",
        details: details
      });
    }

    // snip has extra config
    if (snip.extra !== undefined && snip.extra[currentSnip] !== undefined) {
      // merge extra config
      for (var key in snip.extra[currentSnip]) {
        snip[key] = _.uniq(_.union(snip[key], snip.extra[currentSnip][key]));
      }
    }

    // load browserified version
    if (!noBrowserify) {
      snip.js.push(services.browserifyCDN + pkg.name + "@" + pkg.version);
    }

    // expose other bundles
    if (snip.exposed !== undefined) {
      for (var i = 0; i < snip.exposed.length; i++) {
        snip.js.push(services.browserifyCDN + snip.exposed[i] + "@latest");
      }
    }

    // services.rawgit = "/github/"
    var baseLocal = utils.convertGithubToRaw(services.rawgit + pkg.github.full_name + "/" + pkg.github.default_branch);

    // css
    // the user might specify alternative css locations
    if (snip.buildCSS !== undefined) {
      snip.css = snip.buildCSS;
    }

    // translate all absolute css URLs to github
    for (var i in snip.css) {
      snip.css[i] = utils.translateURL(snip.css[i], baseLocal);
    }

    // package uses parcelify -> so deprecate the entire css
    if (pkg.latest != undefined && pkg.latest.style != undefined) {
      snip.css = [services.parcelifyCDN + pkg.name + "@" + pkg.version];
    }

    // remove the build js (generated by browserify)
    var index = 0;
    while (index < snip.js.length) {
      if (snip.js[index].substring(0, 7) === "/build/") {
        snip.js.splice(index, 1);
      } else {
        snip.js[index] = utils.translateURL(snip.js[index], baseLocal);
        index++;
      }
    }

    // try to download snippets on-the-fly
    if (snip.srcs[currentSnip] === undefined) {
      return superReject({
        msg: "No snippet found.",
        code: "noSnippets",
        details: details
      });
    }
    
    // TODO: dirty hack to get apinatomy working
    if (noBrowserify) {
      snip.srcs[currentSnip].js = undefined;
    }

    snip.inlineScript = "";
    snip.inlineBody = "";

    // load snippets from external sources
    var ps = [];
    ps.push(loadJS(snip, currentSnip, baseLocal));
    ps.push(loadHTML(snip, currentSnip, baseLocal));

    q.all(ps).then(function(){
      superResolve(snip);
    }).catch(function(e){
      superReject(e);
    }).done();
  });
};
